import type { Octokit } from '@octokit/rest';
import { splitRepo } from './github.js';

export async function openDocsPr(gh: Octokit, params: { repo: string; branch: string; readme: string; contributing: string }): Promise<string> {
  const { owner, repo } = splitRepo(params.repo);
  const repoInfo = await gh.rest.repos.get({ owner, repo });
  const base = repoInfo.data.default_branch;
  // ensure branch
  try {
    await gh.rest.git.getRef({ owner, repo, ref: `heads/${params.branch}` });
  } catch (e: any) {
    if (e.status !== 404) throw e;
    const baseRef = await gh.rest.git.getRef({ owner, repo, ref: `heads/${base}` });
    await gh.rest.git.createRef({ owner, repo, ref: `refs/heads/${params.branch}`, sha: baseRef.data.object.sha });
  }
  // upsert files
  const readmeExisting = await safeGetContent(gh, owner, repo, 'README.md', params.branch);
  await gh.rest.repos.createOrUpdateFileContents({ owner, repo, path: 'README.md', branch: params.branch, message: 'docs: add README via Patchly', content: Buffer.from(params.readme, 'utf8').toString('base64'), sha: readmeExisting?.sha });
  const contribExisting = await safeGetContent(gh, owner, repo, 'CONTRIBUTING.md', params.branch);
  await gh.rest.repos.createOrUpdateFileContents({ owner, repo, path: 'CONTRIBUTING.md', branch: params.branch, message: 'docs: add CONTRIBUTING via Patchly', content: Buffer.from(params.contributing, 'utf8').toString('base64'), sha: contribExisting?.sha });
  // PR
  const pr = await gh.rest.pulls.create({ owner, repo, title: 'docs: generate README and CONTRIBUTING (Patchly)', head: params.branch, base, body: 'Generated by Patchly prototype.' });
  return pr.data.html_url;
}

async function safeGetContent(gh: Octokit, owner: string, repo: string, path: string, ref: string) {
  try {
    const r = await gh.rest.repos.getContent({ owner, repo, path, ref });
    if (!Array.isArray(r.data)) return { sha: (r.data as any).sha };
    return null;
  } catch (e: any) {
    if (e.status === 404) return null;
    throw e;
  }
}


